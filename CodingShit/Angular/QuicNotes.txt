binding data in angular three ways- 
Interpolation - {{}}
property binding  - [] inside Html tags
Event binding - click etc.
Two-Way Binding - [(ngModel)]="prop"

Component - In Angular, a component is the basic building block of the UI — it's essentially a class that controls a section of the screen
			(called a "view") and defines the logic, layout, and styling for that section.

Directive -A directive in Angular is a class that adds behavior, appearance, or structure to elements in your Angular application .Unlike components (which have a template),
					 directives don’t have their own UI — they work on existing DOM elements.


	directive can change the behaviour and appearance of DOM element
	Directives can implement all lifecycle hooks
	Directives can not have templates


	directives Type
	Componet directive with template
	structual directive (* is structual deirective can modify DOM) 
		buit-in:-
		<div *ngIf="isLoggedIn">Welcome!</div>
		<ul>
		<li *ngFor="let user of users">{{ user.name }}</li>
		</ul>

		custom:- 
			@Directive({
		selector: '[appUnless]'
		})
		export class UnlessDirective {
		constructor(private templateRef: TemplateRef<any>, private viewContainer: ViewContainerRef) {}

		@Input() set appUnless(condition: boolean) {
			if (!condition) {
			this.viewContainer.createEmbeddedView(this.templateRef);
			} else {
			this.viewContainer.clear();
			}
		}
		}

	Attribute directive (Generally not add or remove element)

		Built-in -
		<p [ngClass]="{ active: isActive }">Styled paragraph</p>
		<p [ngStyle]="{ color: 'red' }">Red text</p>

		custom -
		@Directive({
		selector: '[appHighlight]'
		})
		export class HighlightDirective {
		constructor(el: ElementRef) {
			el.nativeElement.style.backgroundColor = 'yellow';
		}
		}

		Use a directive when:
			You want to modify existing elements (style, behavior, visibility).
			You want to encapsulate behavior that can be reused (e.g., auto-focus, form validation).
			You don’t need a new template (use a component instead if you do).

	Built-in directives
	*ngIf
	*ngFor
	*ngSwitch
	[ngClass]
	[ngStyle]

Router-Outlet - In Angular, <router-outlet> is a directive and placeholder element that tells the Angular router where to render the matched component for a given route.


pipes
pipes are for data transforamtion
pipes doesn't change actual object.
built-in Eg. DatePipe,UpperCasePipe,CurrencyPipe,DecimalPipe,JsonPipe (Mostly use for debugging),slicePipe,AsyncPipe 

Lifecycle hooks
component have lifecycle hooks which use to hook into different events on component
lifecycle ends when component is end

Every lifecycle contains the interface eg. OnInit
ngOnChanges -> change detection -(can be applied on component or directive that has @input) ngOnChanges(change:SimpleChanges)- can be use to log something
ngOnInit
ngDoCheck-> IS used to detect change anywhere in component (generally not used)
			Every time Angular runs change detection, whether anything has changed or not.
			This includes:Input property changes,Events (clicks, form changes),Timer-based triggers (e.g., setTimeout, setInterval)
			Any async operations (HTTP requests, Observables, etc.)
ngAfterConententInit -> used with <ng-content> , Called after Angular projects external content (via <ng-content>),Called only once.
ngAfterConententChecked ->used when we need to do something when the state is changes once.
ngAfterViewInit -> @viewChild by default can be accessed in ngAfterViewInit
ngAfterViewChecked ->
ngOnDestroy ->  Called just before Angular destroys the component.Important for cleanup to avoid memory leaks.
Use case (uses to unsubscribe to the data or to reset some data or do logic on destroy component )



change detection in @component
	changeDetection: ChangeDetectionStrategy.OnPush can be used when component internal data is not going to change , and while using with @input and @output it must be used with
	mutable data ie: we have to initiate data each time on change (arrayList.push(data) won't work instead we must use this.arrayList = [...this.arraylist,data])

@viewchild while initializing component in other component this.component will be undefined in ngOnIntit. By Making @viewChild(,{static:true}) we can use it in ngOnInit when we dont have any asyncronys and static component
@viewchildern is used if there are multiple instance and its staic prpertry is always flase.( operation can be done on first and last child and foreach child)

Dynamic component renderign - <ng-template #user></ng-template> (#user is template reference)
Access HTML element with template reference and assing its value (<div #nane></div> -> @ViewChild('name',{static:true }) name!: ElementRef;)->this.name.nativeElement.innerText = 'Hilton Hotels'

#ngAfterContentInit
contentProjection - <ng-contnet> will pass the content from parent to child and we can access and manupilate its instance in ngContentInit. It is prefered to use Input and Output .(It is use when we dont have control over component) . Example we can use it in FAQs section , design whole section just replace the content of questions.



Dependency Injection( DI)
dependency can be class or object that need to be injected in component and service.
providers
1)class based provider 
2)Value based provider
3)Factory

 class based{{
keep access modifier private - cause service can access it form template

Dependency Resolution-
Before v6 wehave to register service in providers in app.module.ts
root will provide singleton instance accross application
value based provider will create new instance everytime
If you didnt register provider any where in hiararchey you will get nullInjectorError 

Resolution modifier -
-self   : IT is used when we know that we have to initialize service in same component , it will not check service up the hiararchey (kind of type safety)
-Skip self : look up service in upper hiararchey
-optional :can be used when we want some service in development but not in production . if provider is not provided then it will skip the error
-Host Host will be applied on the parent component pause the execution from there
}}

value based{{
	It will provide the value through app.module.ts proviers[{provide,useValue}]
	to access the enviorment variables .
	usecase use to access dom api like localstorage session etc with token 
}}

cmoponent Communication
1)@input and @output
2)@ViewChild and @ContentChild
3)Using Service


<<-- Angular http and observables -->> 
httpclient internally use rxjs
httpRequest - Used for custom requests Supports manual configuration (e.g. reportProgress) Required when you need to track upload/download progress
we can configure proxy using httpClient insted of using CORS 	

observable has observer that will observe for change and internally next method is call. In observable we have three functions 
next(when the stream value is changes),complete(when stream is complete),error(when stream gets some error) 


Rxjs Operators - operators can be use to modify the stream of data
shareReplay  - it is use to cache the data so we dont have to repeate call in stream of data
this.subscription.unsubscribe will use to destroy subscription manually on ngOnDestroy
catcherror - It is use the error handling generally use in service that is use to display error. 
MapOperators - there are diferent map operators it is use to manupilate data form stream .

AsyncPipe - is use to subscribe stream of data  and it will automatically unsubscribe when the ngOnDestroy is called. 

http interceptor - to perform operartions on each http request 
usecase - apply commmon headers , add time stamp to each request , 

App_Initializer - allow to inject function as the app is initialize.	

----------------------------------- Angular Router-----------------------------------



Activated route services is use to (read router data) , (snapshot data) , (access data from router)
snapshot will never detect value change in same view .
router is observable so can be access by pipe or subscribe
param Map contains has and get method to check if property exists to avoid error




---------------------------------FORMS ------------------------------------
There are two types 
1) template driven 
2) reactive form

template driven form need html side form and validation . I will require model to bind the form model with [(ngModle)] .
pristine - means form is not touched 


------------Custom Directive-------------------------------------
Directive can use lifecycle hooks
selector is use to add directive to template '[nameofdirective]'
constructor is use to take the type of 
we can use document as @Inject(DOCUMENT) private:document: Document

Hostlistner - it is use to listen to any event on parent component


we can create the custom validators	by implemeting validation class

=========Tips and tricks==========

1)<div *ngSwitchCase="'User'"></div> (Here User is string not ts variable)
2)Constructor should only uses for injecting some service else logic part goes in onInit()
3)state Managment Libraries always generate pass new instance of data from parent to child.
4)when you here module it will register at @NgModule 
5)represent stream with the $ sign in rxjs

last pause - 10h 56m


To Be Google
-play with watch in console
-get anngular dev tool
-Injection Token
-proxy.config.json
-Factory
-tap and map fuctions
-pipes and subscribe in rxjs
-subject

Advance topics 
ngrx
rxjs other services


we can create service in angular with provierIn : root we can access it from anywhere in application.
and we can provide this service to particular Module 

observable and promises is use to handle asyncronus operaion and asyncronus data 
Eg. const observable = new Observable(subscriber => {
  subscriber.next('Hello');
  subscriber.next('World');
  subscriber.complete();
});

observable.subscribe(value => console.log(value));

An Observable is a data stream that you can subscribe to, and it will emit values over time. Think of it as a way to watch for changes — 
like a radio signal, data keeps coming and you can react to it. (belong to Rxjs)
Commonly use in - http request , form change, Router param , event handling (we can turn dom event to observable)

Common RxJS Operators in Angular
Operator	Purpose
map()	Transform values
filter()	Filter emissions
switchMap()	Cancel previous inner observable and switch to new one
mergeMap()	Flatten and merge multiple observables
catchError()	Handle errors in observable streams
debounceTime()	Wait before emitting value (e.g., in search inputs)

Modules in angular
A module is a container that groups components, directives, pipes, and services. Every Angular application has a root module called AppModule.

What is Change Detection in Angular?
Change detection is the mechanism by which Angular updates the DOM when data changes. Angular uses zones to detect changes and re-render components.
Optimizing with:
ChangeDetectionStrategy.OnPush
ngZone.runOutsideAngular()


What are guards in Angular?
	Guards control access to routes:
	CanActivate, CanDeactivate, Resolve, CanLoad
	CanActivate: Only allow logged-in users to access a dashboard.
	CanDeactivate: Warn the user before leaving a form with unsaved changes.
	CanLoad: Prevent loading of feature modules unless certain conditions are met (e.g., roles or permissions).
	CanActivateChild: Protect child routes of a parent route.
	CanMatch: Advanced matching logic, like A/B testing or experimental routes.


Lazy Loading in abgular	

@ViewChild
In Angular, @ViewChild is a decorator used to get a reference to a child component, directive, or DOM element inside the template.
Useful when you want to call child methods, read child properties, or manipulate DOM directly.